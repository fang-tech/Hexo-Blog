# Agent

> Agent是对以LLM为驱动工程系统, 在整个工程化的结构里面, 最核心的两个脉络是**上下文**和**与外界交互的能力**, 目前出现的任何相关的技术都可以被分类到两者之一, 解决领域中某个特定的问题, 还有一个副主题是**规范制定**, 这是为了让解决上述两个问题的组件能以**通用**的形式接入Agent系统 (仅关注Agent本身的能力, 对于监测, 可视化, 后训练等内容, 在这里被归为Agent调优, 在agent侧本质上也是在调优上面两者, 调优模型不在讨论范围内)

Agent是对LLM的一个工程化包装, 底层调用的模型服务, LLM api能提供的能力及其有限. 你无法通过LLM api去调用你电脑上的某个api, 没办法让ta对和你的对话保有记忆. 一个agent的输入是(用户的message), 输出是(执行action, 输出response).

## 上下文

> agent的运行, 实际上就是上下文的流转, 理解LLM在某个时刻点为什么这么做了, 为什么不这么做的核心就是, 看那一刻该LLM持有了什么上下文

我们假设model是稳定的, 宽泛地将llm视作一个函数, 即假设我们的输入是A, LLM的输出一定是B. 在这种假设下, LLM在某个时刻会给出的输出由他持有的上下文决定(即你给LLM提供的输入).

上下文从生命周期来看分成三类
- 
### 上下文加载方式

 - System Prompt: 系统提示词, 在每次对话开始时候的加载进

### 上下文的种类

agent的回复分成System, Assistant, Tool, User四类, 